\documentclass[letterpaper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    }

\begin{document}
\begin{center}
Описание алгоритма за $O(n^4)$
\end{center}

Алгоритм принимает множество $S$ из $n$ непересекающихся отрезков.
$P$ - множесто концов отрезков $S$, является МТОП.
\begin{enumerate}
      \item Строится множество $L$, прямых, определяющихся любой парой 
            $p_i, p_j \in P$.
            
            Данная операция требует $O(n^2)$ времени, $|L| = 2n^2-n$.
            
            Для дальнейшей обработки множество точек $P$ сохраняется.
            Для каждого отрезка запоминаются индексы его концов.
            Контейнер занимает $2n$ памяти.
      \item Строится упорядочение прямых $A(L)$ с помощью 
            инкрементального алгоритма. Его сложность для $m$ прямых есть 
            \hyperlink{literature_1}{$O(m^2)$}. Соответственно в данном 
            случае потребуется $O(n^4)$.
            
            Результатом работы данного алгоритма является РСДС,
            занимающий линейную память от числа ребер, вершин и граней.
            Так как это число для $A(L)$ квадратично зависит от количества
            прямых в $L$, то расход по памяти на данном этапе алгоритма 
            достигает $O(n^4)$.

            Для каждого ребра сохраняется информация об отрезках из $S$,
            на точках которых была построена прямая, частью которой 
            является данное ребро. 
            
            Также каждое ребро помечается булевым флагом, определяющим 
            лежит оно между задающих его точек или с одной из сторон.
      \item Произвольно выбирается грань $f$ РСДС. Производится
            упорядочивание $P$ по возрастанию полярного угла
            относительно любой внутренней точки грани, обозначим
            точку $q$. Упорядоченное множество $P$ обозначим через $P_u$.
            
            Введем понятие <<правильность>>:
            $f$ - грань РСДС, $q$ - внутренняя точка $f$.
            Назовем отрезок правильным относительно $f$, если 
            его точки являются соседними в $P_u$, построенном относительно
            $q$, а тройка $p_i q p_j$ образовывает левый поворот, 
            в преположении, что $p_i$ находится в $P_u$ раньше.
            Если в $P_u$ всего один отрезок, то он правильный.

            После сортировки все отрезки проверяются на правильность.
            Обозначим через $R$ количество правильных отрезков.

            $P_u$ и $R$ вместе образуют статус.

            Сортировка занимает $O(nlog(n))$, проверка на 
            правильность - $O(n)$.
      \item Производится обход РСДС (например в ширину), начиная с 
            грани $f$. На каждом шаге, зная <<перешагиваемое>> ребро, 
            имеем информацию об индексах $i$ и $j$, порождающиx его точек,
            информацию о положении ребра относительно этих точек. 
            Также имеем информацию об отрезке/отрезках, частью 
            которого/которых являются точки $p_i, p_j$.

            Этой информации и статуса достаточно, чтобы внести изменение 
            в статус: 
            \begin{enumerate}
                  \item Подсчитываем количество правильных отрезков,
                        содержащих $p_i, p_j$, до <<перешагивания>>.
                        Обозначим через $r_b$.
                  \item Вносим изменение в $P_u$ (меняем или не меняем
                        точки $p_i, p_j$ местами).
                  \item Подсчитываем количество правильных отрезков,
                        содержащих $p_i, p_j$, после <<перешагивания>>.
                        Обозначим через $r_a$.
                  \item Перевычислим $R$ : $R = R - r_b + r_a$.
            \end{enumerate}

            На внесение изменений в порядок точек в контейнере и 
            количество правильных отрезков требуется константное время.      
            Таким образом, обработка каждой грани требует $O(1)$ времени 
            и памяти.
      \item Обход продолжается до тех пор пока не найдется грань, 
            в которой $R = n$, или пока не останется непосещенных граней.
            В первом случае ответом алгоритма - <<да>> с предоставлением 
            любой точки внутри найденной грани, 
            во втором случае ответ - <<нет>>.
            
            Обход требует $O(N^4)$ времени.
\end{enumerate}

Источники:

\hypertarget{literature_1}{1.} de Berg, Mark; Cheong, Otfried; van Kreveld, Marc; Overmars, Mark (2008). 
Computational Geometry, Algorithms and Applications (3rd ed.). 
Springer. pp. 172–177. ISBN 978-3-540-77973-5.
\end{document}