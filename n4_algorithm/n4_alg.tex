\documentclass[letterpaper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\begin{document}
\begin{center}
Описание алгоритма за $O(n^4)$
\end{center}
\par
Алгоритм принимает множество $S$ из $n$ непересекающихся отрезков и 
состоит из следующих шагов:
\begin{enumerate}
      \item $P$ - множесто ограничивающих точек отрезков из $S$.
            Строится множество $L$, прямых, определяющихся любой парой $p_i, p_j$ из $P$.
            \par
            Данная операция требует $O(n^2)$ времени, $|L| = 2n^2-n$.
            \par
            Для дальнейшей обработки множество точек $P$ сохраняется в контейнере.
            Для каждого отрезка запоминаются индексы его концов.
            Контейнер занимает $2n$ памяти.
      \item Строится arrangement of lines $A(L)$ с помощью 
            инкрементального алгоритма. Его сложность для $m$ прямых
            есть $O(m^2)$. Соответственно в данном случае потребуется
            $O(n^4)$.
            \par
            Результатом работы данного алгоритма является РСДС,
            занимающий линейную память от числа ребер, вершин и граней.
            Так как это число для $A(L)$ квадратично зависит от количества
            прямых в $L$, то расход по памяти на данном этапе алгоритма достигает
            $O(n^4)$.
            \par
            Для каждого ребра сохраняется информация об отрезках из $S$,
            на точках которых была построена прямая, 
            частью которой является данное ребро.
      \item Находится любая непустая грань $f$ РСДС, производится упорядочивание $P$ 
            по возрастанию полярного угла относительно любой вершины $q$ данной грани.
            \par
            В случае равенства дополнительно производится следующая операция:
            \begin{enumerate}
                  \item Из двух сходящихся в $q$ ребер $f$ находится то, 
                        которое является частью прямой, проходящей через равные точки. 
                  \item Производится сдвиг от него на $\varepsilon$ по нормали в сторону $f$.
                  \item Значения углов пересчитываются, точки заносятся в получившемся порядке.
            \end{enumerate}
            \par
            После сортировки все отрезки проверяются на <<правильность>> 
            (индексы $i$ и $j$ точек отрезка в контейнере должны быть соседними,
            $p_i q p_j$ должны образовывать левый поворот). 
            Количество правильных отрезков запоминается. Сортировка занимает 
            $O(nlog(n))$, проверка на правильность - $O(n)$.
      \item Производится обход РСДС (например в ширину), начиная с грани $f$. 
            На каждом шаге, зная <<перешагиваемое>> ребро,
            через обращение к отрезкам находятся индексы, порождающиx его точек. 
            \par
            Если точки относятся к одному отрезку, они меняются местами в контейнере.
            В противном случае для всех точек, задающих отрезки (их 4), производится 
            упорядочивание из прошлого пункта для граней до и после <<перешагивания>>.
            Результаты сравниваются и, если они не равны, точки отрезков, 
            которые задают ребро, меняются местами.
            \par
            Все отрезки, которые затронула прошлая операция, проверяются на
            <<правильность>>, вносится изменение в число <<правильных>> отрезков
            (если надо).
            \par
            Обработка каждой грани требует $O(1)$ времени и памяти. 
      \item Обход продолжается до тех пор пока не найдется \textsl{непустая}
            грань, в которой все отрезки окажутся <<правильными>>, или пока не
            останется непосещенных граней. В первом случае ответом алгоритма - <<да>>
            с предоставлением любой точки внутри найденной грани, во втором
            случае ответ - <<нет>>.
            \par
            Обход требует $O(N^4)$ времени.
\end{enumerate}
\end{document}